% Created 2017-02-07 Tue 18:56
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in]{geometry}
\usepackage{libertine}
\usepackage[scaled=0.9]{inconsolata}
\DeclareMathOperator{\modulo}{modulo}
\usepackage{etoolbox}
\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother
\author{Eduardo Acuña Yeomans}
\date{\today}
\title{Conway's Game of Life}
\hypersetup{
 pdfauthor={Eduardo Acuña Yeomans},
 pdftitle={Conway's Game of Life},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.1.1 (Org mode 9.0.4)}, 
 pdflang={English}}
\begin{document}

\maketitle

\section{Introduction}
\label{sec:orgc83512f}

This document describes a first attempt at implementing the classic zero-player game \emph{Conway's Game of Life} in Javascript using the React JS library.

The Game of Life (GOL for short) consists of a two-dimensional grid of \emph{cells} representing living things. Each cell can be in one of two states, alive or dead, and each turn some cells die, some are born and others stay in the same state. The game requires an initial condition as input, that is, which cells are alive and which are dead; from there a particular set of rules are applied iteratively to each cell and the configuration evolves over time, rendering a beautiful simulation of apparent randomness and chaos.

The GOL rules for each cell involve counting the number of living cells in the \emph{neighborhood} of a particular cell. In the following image the neighborhood of a cell (pictured in blue) consists of all the adjacent cells (pictured in red).

\begin{center}
\includegraphics[width=10em]{./img/neighbors.png}
\label{orgf6017cc}
\end{center}

The evolution of every cell in the grid, from one step of the game to the next, obeys the following rules:
\begin{itemize}
\item Any living cell with fewer than two live neighbours dies;
\item Any living cell with two or three living neighbours lives on to the next generation;
\item Any living cell with more than three living neighbours dies;
\item Any dead cell with exactly three living neighbours becomes a live cell.
\end{itemize}

\section{The grid abstraction}
\label{sec:org57c5c10}

The two-dimensional grid in GOL is infinite by definition, but this implementation in particular, the grid will be of finite size with connected frontiers. The implementation provides means to:
\begin{enumerate}
\item Create a new grid with values assigned by location.
\item Obtain the number of rows and columns of a grid.
\item Obtain the value of a particular location of a grid.
\item Assign a value to a particular location of a grid.
\end{enumerate}

\subsection{Creating a grid}
\label{sec:org02e14e2}

The function \texttt{make} handles the creation of a new grid. Grids are implemented as arrays of rows, where each row is also an array of values.

The arguments of \texttt{make} are the number of rows and columns, and a function that takes two arguments (the position in the grid) and returns a value.

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:orgd148605}
\begin{minted}[]{js}
function make(nrows, ncols, makeValue) {
  let g = Array(nrows);
  for (let i = 0; i < nrows; i++) {
    g[i] = Array(ncols);
    for (let j = 0; j < ncols; j++) {
      g[i][j] = makeValue(i, j);
    }
  }
  return g;
}
\end{minted}

\subsection{Obtaining the rows and columns of a row}
\label{sec:org33a51aa}

The \texttt{countRows} and \texttt{countCols} functions compute the number of rows and columns respectively for a given grid.

Given that the grid is represented as an Array of rows, to obtain it's length one must access the \texttt{length} property. Easy peasy lemon squeezy:

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:orga168000}
\begin{minted}[]{js}
function countRows(grid) {
  return grid.length;
}
\end{minted}

The number of columns of a grid is almost as easy to determine, it's a matter of calculating the length of any of its rows:

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:orgec5060f}
\begin{minted}[]{js}
function countCols(grid) {
  return grid[0].length;
}
\end{minted}

\subsection{Getting a particular value of a grid}
\label{sec:org687912e}

Locations on a grid are determined by a row and column index, however given that the grid must have connected frontiers one must use some modular arithmetic to handle locations outside the limits of the array.

Javascript's \texttt{\%} operator computes the \emph{remainder}, to compute \(\modulo(a,b)\) one can take into account the following:
\begin{itemize}
\item \(a \geq 0 \implies \modulo(a,b) = a \% b\)
\item \(a < 0 \implies a \% b = r \in (-b,0],\ (b+r)\%b = \modulo(a,b) = (b + (a \% b)) \% b\)
\item \(a \geq 0 \implies (b + (a \% b)) \% b = (b + \modulo(a,b)) \% b = \modulo(a,b)\)
\end{itemize}

The \texttt{modulo} implementation is defined as:

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:org699d222}
\begin{minted}[]{js}
function modulo(a, b) {
  return ((a % b) + b) % b;
}
\end{minted}


Now one can simply define the function \texttt{ref} in terms of array indexing and \texttt{modulo} to obtain the value of a given location in a grid.

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:org5af4269}
\begin{minted}[]{js}
function ref(grid, i, j) {
  return grid[modulo(i, countRows(grid))][modulo(j, countCols(grid))];
}
\end{minted}

\subsection{Changing a grid value}
\label{sec:org5763d39}

Simmilar to the \texttt{ref} function, the implementation of \texttt{set} accepts an aditional value argument to be placed in the specified location of a grid.

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:orgbd1d8fd}
\begin{minted}[]{js}
function set(grid, i, j, value) {
  grid[modulo(i, countRows(grid))][modulo(j, countCols(grid))] = value;
}
\end{minted}

\subsection{Interface}
\label{sec:org2c7beea}

The file \texttt{src/grid.js} contains the code from this section, the object \texttt{grid} is the interface used in other files:

\subsubsection{\texttt{<src/grid.js>}}
\label{sec:orgd5f9c0d}
\begin{minted}[]{js}
var grid = {};
grid.make = make;
grid.countRows = countRows;
grid.countCols = countCols;
grid.ref = ref;
grid.set = set;
\end{minted}

\section{Life rules}
\label{sec:org38eb445}

The next step involves implementing a layer of abstraction on top of grids that represents the GOL rules. This task concearns the following problems:
\begin{itemize}
\item How to encode GOL concepts with grids.
\item How to handle GOL transitions.
\end{itemize}

The following sections tackle these points.

\subsection{Mapping life to grids}
\label{sec:org870b5c6}

A GOL grid is going to be a grid whose locations hold cells, represented by the values \texttt{alive} or \texttt{dead}. The rules of GOL take into consideration the number of live neighbors of a particular cell, therefore it's convenient to represent the cell's values as \texttt{1} and \texttt{0}, so one can add the alive neighbors more easily.

\subsubsection{\texttt{<src/life.js>}}
\label{sec:org8435b3c}
\begin{minted}[]{js}
const alive = 1;
const dead = 0;
\end{minted}

To provide a constructor, getter and setter for GOL grids, one can leverage the \texttt{grid.make}, \texttt{grid.ref} and \texttt{grid.set} implementations.

\subsubsection{\texttt{<src/life.js>}}
\label{sec:org5b430d7}
\begin{minted}[]{js}
function make(nrows, ncols, makeCell) {
  return grid.make(nrows, ncols, makeCell);
}

var countRows = grid.countRows;
var countCols = grid.countCols;

function ref(life, i, j) {
  return grid.ref(life, i, j);
}

function set(life, i, j, cell) {
  grid.set(life, i, j, cell);
}
\end{minted}

One aspect of GOL grids is that each cell has an associated \emph{degree} of some sort (the number of \texttt{alive} neighbors). The function \texttt{neighbors} computes this value for a given cell location:

\subsubsection{\texttt{<src/life.js>}}
\label{sec:org4f488cd}
\begin{minted}[]{js}
function neighbors(life, i, j) {
  return ref(life, i-1, j-1) + ref(life, i  , j-1) + ref(life, i+1, j-1) +
         ref(life, i-1, j  ) +          0          + ref(life, i+1, j  ) +
         ref(life, i-1, j+1) + ref(life, i  , j+1) + ref(life, i+1, j+1);
}
\end{minted}

\subsection{Evolving life}
\label{sec:orgf154447}

The next step involves implementing a one-step evolution for a GOL grid. To achive this one can determine a particular cell \emph{future} with respect to it's value and neighborhood, the following table describes the transition for every possible combination of those two factors.

\begin{center}
\label{tab:org830a7ee}
\begin{tabular}{ccc}
State \(n\) & Neighbors & State \(n+1\)\\
\hline
\emph{dead} & 0 & \emph{dead}\\
\emph{dead} & 1 & \emph{dead}\\
\emph{dead} & 2 & \emph{dead}\\
\emph{dead} & 3 & \emph{\textbf{alive}}\\
\emph{dead} & 4 & \emph{dead}\\
\emph{dead} & 5 & \emph{dead}\\
\emph{dead} & 6 & \emph{dead}\\
\emph{dead} & 7 & \emph{dead}\\
\emph{dead} & 8 & \emph{dead}\\
\emph{alive} & 0 & \emph{dead}\\
\emph{alive} & 1 & \emph{dead}\\
\emph{alive} & 2 & \emph{\textbf{alive}}\\
\emph{alive} & 3 & \emph{\textbf{alive}}\\
\emph{alive} & 4 & \emph{dead}\\
\emph{alive} & 5 & \emph{dead}\\
\emph{alive} & 6 & \emph{dead}\\
\emph{alive} & 7 & \emph{dead}\\
\emph{alive} & 8 & \emph{dead}\\
\end{tabular}
\end{center}


In a cell transition step, most of combinations in the table result in a \texttt{dead} value. To implement the procedure \texttt{lifeCellFuture} one must handle the bold cases:
\begin{itemize}
\item When a cell has 3 neighbors it always results in \texttt{alive}.
\item When a cell has 2 neighbors then the previous value prevails.
\item Otherwise, the cell remains \texttt{dead} or dies.
\end{itemize}
\subsubsection{\texttt{<src/life.js>}}
\label{sec:orgb0f489c}
\begin{minted}[]{js}
function cellFuture(life, i, j) {
  switch (neighbors(life, i, j)) {
  case 3:
    return alive;
  case 2:
    return ref(life, i, j);
  default:
    return dead;
  }
}
\end{minted}

Finally, to evolve the whole GOL grid and return the next version, one can use the abstractions previously defined:

\subsubsection{\texttt{<src/life.js>}}
\label{sec:orgdc60d5c}
\begin{minted}[]{js}
function evolve(life) {
  return make(countRows(life), countCols(life),
              (i, j) => cellFuture(life, i, j));
}
\end{minted}

\subsection{Interface}
\label{sec:org197b85a}

The file \texttt{src/life.js} contains the code from this section, the object \texttt{life} is the interface used in other files;

\subsubsection{\texttt{<src/life.js>}}
\label{sec:orgfd8aa97}
\begin{minted}[]{js}
var life = {};
life.alive = alive;
life.dead = dead;
life.make = make;
life.countRows = countRows;
life.countCols = countCols;
life.ref = ref;
life.set = set;
life.evolve = evolve;
\end{minted}

\section{React JS Components}
\label{sec:orgb9dbcf2}

From what I understand, React JS components are the algorithmic representation of some substructure in an HTML document.

To implement the interface for GOL I imagined how the HTML will look. Obviously there must be some kind of grid, and some controls to play/pause the game, kill every cell and generate a random initial condition. Also, the cells in the grid must be clickable to toggle their value.

The code in this section uses the \texttt{life.js} source file.

To accomplish the stated vision, create the \texttt{ConwaysGame} \emph{component} that will have as state a GOL grid, and a flag that determines wether the game is playing or is paused. Also, one must handle the click of a cell, and the clicks of every button. The general structure of \texttt{ConwaysGame} is:

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:orgdc3d876}
\begin{minted}[]{js}
class ConwaysGame extends React.Component {
  <<gol-constructor>>
  <<gol-timer-setup>>
  <<gol-simulation>>
  <<gol-grid-click>>
  <<gol-play-pause-click>>
  <<gol-clear-click>>
  <<gol-randomize-click>>
  render() { 
    return (
        <<gol-view>>
    );
  }
}
\end{minted}

\subsection{Evolving life periodically}
\label{sec:org07719b8}

The first thing one must set in place is the ability to update the grid as times goes on. This is done by setting a timer with the \texttt{setInterval} function, and with each tick of the timer the state of GOL must evolve. The \texttt{componentDidMount} function from the React component lifecycle, get's called after the rendering of the component, here one must set an interval with ticks every 10 milliseconds. The \texttt{componentWillUnmount} function get's called before the component is removed from the DOM, here the interval get's cleared and the \texttt{evolve} function won't be invoked.

\subsubsection{\texttt{<<gol-timer-setup>>}}
\label{sec:orgd936565}
\begin{minted}[]{js}
componentDidMount() {
  this.gameId = setInterval(() => this.evolve(), 10);
}

componentWillUnmount() {
  clearInterval(this.gameId);
}
\end{minted}

The definition of the \texttt{evolve} function is pretty straight-forward. When the simulation must be playing (that is, when \texttt{state.playing} is \texttt{true}) a new state is set with \texttt{state.grid} updated to a new GOL configuration given by \texttt{life.evolve}:

\subsubsection{\texttt{<<gol-simulation>>}}
\label{sec:org9674564}
\begin{minted}[]{js}
evolve() {
  if (this.state.playing) {
    this.setState((previous, props) => ({
      grid: life.evolve(previous.grid),
      playing: previous.playing
    }));
  }
}
\end{minted}

\subsection{Controlling the grid}
\label{sec:org71cdcc1}

There are four different ways to controll the grid:
\begin{itemize}
\item Clicking on a particular location of the grid.
\item Clicking the play/pause button.
\item Clicking the clear button.
\item Clicking the randomize button.
\end{itemize}

The \texttt{handleGridClick} function will take the clicked location as arguments and change the internal state to a toggled version of that location, that is, if the cell was dead now it will be alive and vice versa.

\subsubsection{\texttt{<<gol-grid-click>>}}
\label{sec:org9783406}
\begin{minted}[]{js}
handleGridClick(i, j) {
  const grid = this.state.grid;
  const cell = life.ref(grid, i, j);
  const modcell = (cell == life.alive) ? life.dead : life.alive;
  let modgrid = life.make(life.countRows(grid), life.countCols(grid),
                          (k, p) => ((i == k) && (j == p) ? modcell : life.ref(grid, k, p)));
  this.setState((previous, props) => ({
    grid: modgrid,
    playing: previous.playing
  }));
}
\end{minted}

The \texttt{handlePlayPause} function will be a thunk that toggles the value of \texttt{state.playing}:

\subsubsection{\texttt{<<gol-play-pause-click>>}}
\label{sec:org8e55a88}
\begin{minted}[]{js}
handlePlayPauseClick() {
  this.setState({
    grid: this.state.grid,
    playing: !this.state.playing
  });
}
\end{minted}

The \texttt{handleClearClick} function will be a thunk that resets \texttt{state.grid} to just dead cells:

\subsubsection{\texttt{<<gol-clear-click>>}}
\label{sec:org5659879}
\begin{minted}[]{js}
handleClearClick() {
  const grid = this.state.grid;
  let modgrid = life.make(life.countRows(grid), life.countCols(grid), () => life.dead);
  this.setState({
    grid: modgrid,
    playing: this.state.playing
  });
}
\end{minted}

Finally, the \texttt{handleRandomizeClick} will be a thunk that resets \texttt{state.grid} to cells either dead or alive with a random distribution:

\subsubsection{\texttt{<<gol-randomize-click>>}}
\label{sec:orgf3470e5}
\begin{minted}[]{js}
handleRandomizeClick() {
  const grid = this.state.grid;
  let randomgrid = life.make(life.countRows(grid), life.countCols(grid),
                             () => this.randomCell());
  this.setState({
    grid: randomgrid,
    playing: this.state.playing
  });
}

randomCell() {
  const outcomes = [life.dead, life.alive];
  return outcomes[Math.floor(outcomes.length * Math.random())];
}
\end{minted}

\subsection{GOL initialization}
\label{sec:org5c5290e}

The \texttt{ConwaysGame} component will be instantiated as:
\begin{minted}[]{html}
<ConwaysGame nrows=n ncols=m />
\end{minted}
so that the \texttt{nrows} and \texttt{ncols} properties, which determine the size of the grid, can be accessed.

The constructor does the basic initialization: setting the initial state and binding the \texttt{this} value for the functions defined previously:

\subsubsection{\texttt{<<gol-constructor>>}}
\label{sec:orgf7c4353}
\begin{minted}[]{js}
constructor(props) {
  super(props);
  const nrows = props.nrows;
  const ncols = props.ncols;
  this.state = {
    grid: life.make(nrows, ncols, () => life.dead),
    playing: false
  };
  this.handleGridClick = this.handleGridClick.bind(this);
  this.handlePlayPauseClick = this.handlePlayPauseClick.bind(this);
  this.handleClearClick = this.handleClearClick.bind(this);
  this.handleRandomizeClick = this.handleRandomizeClick.bind(this);
  this.evolve = this.evolve.bind(this);
}
\end{minted}

Finally the \texttt{render} function return value get's setup, which delegates the rendering of the controls and the grid to the \texttt{PlayPauseButton}, \texttt{ClearButton}, \texttt{RandomizeButton} and \texttt{VisualGrid} components, which will be simpler than \texttt{ConwaysGame} and won't hold any state.

\subsubsection{\texttt{<<gol-view>>}}
\label{sec:orga70f4d1}
\begin{minted}[]{html}
<div className="gol-main">
  <div className="gol-controls">
    <PlayPauseButton
      callback={this.handlePlayPauseClick}
      status={this.state.playing} />
    <ClearButton
      callback={this.handleClearClick} />
    <RandomizeButton
      callback={this.handleRandomizeClick} />
  </div>
  <VisualGrid
    callback={this.handleGridClick}
    grid={this.state.grid} />
</div>
\end{minted}

\subsection{Playing and pausing the game}
\label{sec:org5ccf4c6}

The \texttt{PlayPauseButton} component renders different buttons depending on the value of \texttt{props.status}:

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:org5e2ad6a}
\begin{minted}[]{js}
function PlayPauseButton(props) {
  const status = props.status;
  if (status) {
    return (
        <<control-pause>>
    );
  } else {
    return ( 
        <<control-play>>
    );
  }
}
\end{minted}

These buttons are represented in the following way:

\subsubsection{\texttt{<<control-pause>>}}
\label{sec:org9f4baa3}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-pause">
  <b>Pause</b>
</button>
\end{minted}

\subsubsection{\texttt{<<control-play>>}}
\label{sec:orge2d8d0c}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-play">
  <b>Play</b>
</button>
\end{minted}

\subsection{Clearing and randomizing the game}
\label{sec:org48e9f77}

These buttons are simmilar to \texttt{PlayPauseButton}:

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:org36f0be1}
\begin{minted}[]{js}
function ClearButton(props) {
  return ( 
      <<control-clear>>
  );
}
\end{minted}

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:orgdf67754}
\begin{minted}[]{js}
function RandomizeButton(props) {
  return (
      <<control-randomize>> 
  );
}
\end{minted}

Where \texttt{<<control-clear>>} and \texttt{<<control-randomize>>} have obvious definitions:

\subsubsection{\texttt{<<control-clear>>}}
\label{sec:org51e40e8}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-clear">
  <b>Clear</b>
</button>
\end{minted}

\subsubsection{\texttt{<<control-randomize>>}}
\label{sec:org940dd9e}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-randomize">
  <b>Randomize</b>
</button>
\end{minted}

\subsection{Grid visualization}
\label{sec:org6504856}

This last component takes care of rendering the grid as an HTML table, where each cell has a different click callback:

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:orgd334b84}
\begin{minted}[]{js}
function VisualGrid(props) {
  const grid = props.grid;
  let rows = Array(life.countRows(grid));
  for (let i = 0; i < life.countRows(grid); i++) {
    let arr = Array(life.countCols(grid));
    for (let j = 0; j < life.countCols(grid); j++) {
      let cell = life.ref(grid, i, j);
      arr[j] = (
          <<table-cell>>
      );
    }
    rows[i] = (
        <<table-row>>
    );
  }
  return (
      <<table-main>>
  );
}
\end{minted}

The visual representation of a cell's value is the background color of an HTML table cell:

\subsubsection{\texttt{<<table-cell>>}}
\label{sec:orgfbd8623}
\begin{minted}[]{html}
<td key={j} className="cell" style={{backgroundColor: (cell == life.alive ? "white" : "black")}}
    onClick={ () => props.callback(i, j) }
  />
\end{minted}

The rest of the table structure is trivial:

\subsubsection{\texttt{<<table-row>>}}
\label{sec:org2524783}
\begin{minted}[]{html}
<tr key={i}>
  { arr }
</tr>
\end{minted}

\subsubsection{\texttt{<<table-main>>}}
\label{sec:org1694974}
\begin{minted}[]{html}
<table className="grid">
  <tbody>
    { rows }
  </tbody>
</table>
\end{minted}

\subsection{Rendering into the DOM}
\label{sec:org802715f}

The last step is render the \texttt{ConwaysGame} component in the DOM using the \texttt{render} function from \texttt{ReactDOM}. The following chunk of code injects \texttt{<<conways-game>>} in the HTML element with ID \texttt{root}:

\subsubsection{\texttt{<src/reactlife.jsx>}}
\label{sec:org16fddb8}
\begin{minted}[]{js}
ReactDOM.render(
  <<conways-game>>,
  document.getElementById('root')
);
\end{minted}

The number of rows and columns are set to 30:

\subsubsection{\texttt{<<conways-game>>}}
\label{sec:orgf763a13}
\begin{minted}[]{html}
<ConwaysGame ncols={30} nrows={30} />
\end{minted}

\section{The HTML document}
\label{sec:org1abc3cd}

This last section includes the main HTML and CSS files:

\subsubsection{\texttt{<src/index.html>}}
\label{sec:org00b7afa}
\begin{minted}[]{html}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Conway's Game of Life</title>
    <script src="https://unpkg.com/react@latest/dist/react.js"></script>
    <script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <link rel="stylesheet" type="text/css"
          href="../style/solarized-light.css" />
    <link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+SC" rel="stylesheet">
    <style> body { font-family: 'Alegreya', serif; } </style>
    <style> h1, h2, h3 { font-family: 'Alegreya SC', serif; } </style>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="text-align: center;">Conway's Game of Life Demo</h1>
    <div id="root"></div>

    <script src="grid.js"></script>
    <script src="life.js"></script>
    <script type="text/babel" src="reactlife.jsx"></script>
  </body>
</html>
\end{minted}

\subsubsection{\texttt{<src/style.css>}}
\label{sec:orgf1a3f7c}
\begin{minted}[]{css}
.gol-main {}

.gol-controls {
    text-align: center;
}

.btn-pause {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-play {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-clear {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-randomize {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.cell {
    display: inline-block;
    width: 22px;
    height: 22px;
    cursor: pointer;
    margin: 0px;
    padding: 0px;
    border: solid 1px #333;
}

.grid {
    margin: auto;
    border-spacing: 0px;
    border: solid 2px #333;
}
\end{minted}
\end{document}