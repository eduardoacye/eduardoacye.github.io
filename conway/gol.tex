% Created 2017-02-03 Fri 23:42
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in]{geometry}
\usepackage{libertine}
\usepackage[scaled=0.9]{inconsolata}
\DeclareMathOperator{\modulo}{modulo}
\setcounter{secnumdepth}{2}
\author{Eduardo Acuña Yeomans}
\date{\today}
\title{Conway's Game of Life}
\hypersetup{
 pdfauthor={Eduardo Acuña Yeomans},
 pdftitle={Conway's Game of Life},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.1.1 (Org mode 9.0.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec:org0d3fb80}

This document describes my first attempt at implementing the classic zero-player game \emph{Conway's Game of Life} in Javascript using the React JS library.

The Game of Life (GOL for short) consists of a two-dimensional grid of \emph{cells} representing living things. Each cell can be either alive or dead and each turn some cells die, some born and others stay the same. The game requires an initial condition as input, that is: which cells are alive and which are dead; from there, a particular set of rules are applied iteratively to each cell and the configuration evolves over time, rendering beautiful apparent randomness and chaos.

The GOL rules for each cell involve counting the number of living cells in the \emph{neighborhood} of a particular cell. In the following picture the neighborhood of the blue cell consists of the cells painted in red.

\begin{center}
\includegraphics[width=10em]{./img/neighbors.png}
\label{org9c2764e}
\end{center}

The transitions for every cell in the grid from one step of the game to the next are as follows:
\begin{itemize}
\item Any live cell with fewer than two live neighbours dies;
\item Any live cell with two or three live neighbours lives on to the next generation;
\item Any live cell with more than three live neighbours dies;
\item Any dead cell with exactly three live neighbours becomes a live cell.
\end{itemize}

\section{The grid abstraction}
\label{sec:orgc0c541f}

The two-dimensional grid in GOL is infinite by definition, but this implementation in particular will be a finite grid with connected frontiers. The implementation provides means to:
\begin{enumerate}
\item Create a new grid with values assigned by location.
\item Obtain the number of rows and columns of a grid.
\item Obtain the value of a particular location of a grid.
\item Assign a value to a particular location of a grid.
\end{enumerate}

\subsection{Creating a grid}
\label{sec:org3697b07}

The function \texttt{make} handles the creation of a new grid. Grids are implemented as arrays of rows, where each row is also an array of values.

The arguments of \texttt{make} are the number of rows and columns, and a function that takes two arguments (the position in the grid) and returns a value.

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:org70bb8e7}
\begin{minted}[]{js}
function make(nrows, ncols, makeValue) {
  let g = Array(nrows);
  for (let i = 0; i < nrows; i++) {
    g[i] = Array(ncols);
    for (let j = 0; j < ncols; j++) {
      g[i][j] = makeValue(i, j);
    }
  }
  return g;
}
\end{minted}

\subsection{Obtaining the rows and columns of a row}
\label{sec:org3b5dc1a}

The \texttt{countRows} and \texttt{countCols} functions compute the number of rows and columns respectively for a given grid.

Given that the grid is represented as an Array of rows we can obtain it's length with the \texttt{length} property. Easy peasy lemon squeezy:

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:orgb64652c}
\begin{minted}[]{js}
function countRows(grid) {
  return grid.length;
}
\end{minted}

The number of columns is almost as easy, we just need to obtain the length of any of it's rows:

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:org326bd2b}
\begin{minted}[]{js}
function countCols(grid) {
  return grid[0].length;
}
\end{minted}

\subsection{Get a particular value of a grid}
\label{sec:orgb1425ed}

Locations in a grid are determined by a row and column index, however given that we want to have a grid with connected frontiers we must use some modular arithmetic to handle locations outside the limits of the array.

Javascript's \texttt{\%} operator computes the \emph{remainder}, to compute \(\modulo(a,b)\) we need to take into account the following:
\begin{itemize}
\item \(a \geq 0 \implies \modulo(a,b) = a \% b\)
\item \(a < 0 \implies a \% b = r \in (-b,0],\ (b+r)\%b = \modulo(a,b) = (b + (a \% b)) \% b\)
\item \(a \geq 0 \implies (b + (a \% b)) \% b = (b + \modulo(a,b)) \% b = \modulo(a,b)\)
\end{itemize}

The \texttt{modulo} implementation is defined as:

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:org12c3d7a}
\begin{minted}[]{js}
function modulo(a, b) {
  return ((a % b) + b) % b;
}
\end{minted}


Now we can simply define the function \texttt{ref} in terms of array indexing and \texttt{modulo} to obtain the value of a given location in a grid.

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:orgf029ee3}
\begin{minted}[]{js}
function ref(grid, i, j) {
  return grid[modulo(i, countRows(grid))][modulo(j, countCols(grid))];
}
\end{minted}

\subsection{Changing a grid value}
\label{sec:org0acb416}

Simmilar to the \texttt{ref} function, we implement \texttt{set} to accept an aditional value argument to be placed in the specified location of a grid.

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:orge0b7c12}
\begin{minted}[]{js}
function set(grid, i, j, value) {
  grid[modulo(i, countRows(grid))][modulo(j, countCols(grid))] = value;
}
\end{minted}

\subsection{Interface}
\label{sec:org76edc08}

The file \texttt{src/grid.js} contains the code from this section, the object \texttt{grid} is the interface used in other files:

\subsubsection*{\texttt{<src/grid.js>}}
\label{sec:org727638d}
\begin{minted}[]{js}
var grid = {};
grid.make = make;
grid.countRows = countRows;
grid.countCols = countCols;
grid.ref = ref;
grid.set = set;
\end{minted}

\section{Life rules}
\label{sec:org20aca7d}

Now we implement a layer of abstraction on top of grids that implements the GOL rules. This task concearns the following problems:
\begin{itemize}
\item How to encode GOL concepts with grids.
\item How to handle GOL transitions.
\end{itemize}

The following sections tackle these points.

\subsection{Mapping life to grids}
\label{sec:orgd838108}

A GOL grid is going to be a grid whose locations hold cells, represented by the values \texttt{alive} or \texttt{dead}. The rules of GOL take into consideration the number of live neighbors of a particular cell, therefore it's convenient to represent the cell's values as \texttt{1} and \texttt{0}, so we can add the alive neighbors more easily.

\subsubsection*{\texttt{<src/life.js>}}
\label{sec:orgb36fe58}
\begin{minted}[]{js}
const alive = 1;
const dead = 0;
\end{minted}

To provide a constructor, getter and setter for GOL grids, we leverage the \texttt{grid.make}, \texttt{grid.ref} and \texttt{grid.set} implementations. The only thing we must be careful is to use the cell values \texttt{alive} or \texttt{dead} when using the following functions:

\subsubsection*{\texttt{<src/life.js>}}
\label{sec:org09e2266}
\begin{minted}[]{js}
function make(nrows, ncols, makeCell) {
  return grid.make(nrows, ncols, makeCell);
}

var countRows = grid.countRows;
var countCols = grid.countCols;

function ref(life, i, j) {
  return grid.ref(life, i, j);
}

function set(life, i, j, cell) {
  grid.set(life, i, j, cell);
}
\end{minted}

One aspect of GOL grids is that each cell has an associated \emph{degree} of some sort (the number of \texttt{alive} neighbors). The function \texttt{neighbors} computes this value for a given cell location:

\subsubsection*{\texttt{<src/life.js>}}
\label{sec:org079fa99}
\begin{minted}[]{js}
function neighbors(life, i, j) {
  return ref(life, i-1, j-1) + ref(life, i  , j-1) + ref(life, i+1, j-1) +
         ref(life, i-1, j  ) +          0          + ref(life, i+1, j  ) +
         ref(life, i-1, j+1) + ref(life, i  , j+1) + ref(life, i+1, j+1);
}
\end{minted}

\subsection{Evolving life}
\label{sec:org693073d}

Now we proceed to implement a one-step evolution for a GOL grid. The first step is determining a particular cell \emph{future} with respect to it's value and neighborhood, the following table describes the transition for every possible combination of those two factors.

\begin{center}
\label{tab:orge96af64}
\begin{tabular}{ccc}
State \(n\) & Neighbors & State \(n+1\)\\
\hline
\emph{dead} & 0 & \emph{dead}\\
\emph{dead} & 1 & \emph{dead}\\
\emph{dead} & 2 & \emph{dead}\\
\emph{dead} & 3 & \emph{\textbf{alive}}\\
\emph{dead} & 4 & \emph{dead}\\
\emph{dead} & 5 & \emph{dead}\\
\emph{dead} & 6 & \emph{dead}\\
\emph{dead} & 7 & \emph{dead}\\
\emph{dead} & 8 & \emph{dead}\\
\emph{alive} & 0 & \emph{dead}\\
\emph{alive} & 1 & \emph{dead}\\
\emph{alive} & 2 & \emph{\textbf{alive}}\\
\emph{alive} & 3 & \emph{\textbf{alive}}\\
\emph{alive} & 4 & \emph{dead}\\
\emph{alive} & 5 & \emph{dead}\\
\emph{alive} & 6 & \emph{dead}\\
\emph{alive} & 7 & \emph{dead}\\
\emph{alive} & 8 & \emph{dead}\\
\end{tabular}
\end{center}


In a cell transition step, most of combinations in the table result in a \texttt{dead} value. To implement the procedure \texttt{lifeCellFuture} we must handle the bold cases:
\begin{itemize}
\item When a cell has 3 neighbors it always results in \texttt{alive}.
\item When a cell has 2 neighbors then the previous value prevails.
\item Otherwise, the cell remains \texttt{dead} or dies.
\end{itemize}
\subsubsection*{\texttt{<src/life.js>}}
\label{sec:org290f72a}
\begin{minted}[]{js}
function cellFuture(life, i, j) {
  switch (neighbors(life, i, j)) {
  case 3:
    return alive;
  case 2:
    return ref(life, i, j);
  default:
    return dead;
  }
}
\end{minted}

Finally, we need to evolve the whole GOL grid and return the next version, with the abstractions previously defined this is simple:

\subsubsection*{\texttt{<src/life.js>}}
\label{sec:org0371ebd}
\begin{minted}[]{js}
function evolve(life) {
  return make(countRows(life), countCols(life),
              (i, j) => cellFuture(life, i, j));
}
\end{minted}

\subsection{Interface}
\label{sec:org72ec596}

The file \texttt{src/life.js} contains the code from this section, the object \texttt{life} is the interface used in other files;

\subsubsection*{\texttt{<src/life.js>}}
\label{sec:org1949a7d}
\begin{minted}[]{js}
var life = {};
life.alive = alive;
life.dead = dead;
life.make = make;
life.countRows = countRows;
life.countCols = countCols;
life.ref = ref;
life.set = set;
life.evolve = evolve;
\end{minted}

\section{React JS Components}
\label{sec:orgbbbc083}

From what I understand, React JS components are the algorithmic representation of some substructure in an HTML document.

To implement the interface for GOL I imagined how the HTML will look. Obviously there must be some kind of grid, and some controls to play/pause the game, kill every cell and generate a random initial condition. Also, the cells in the grid must be clickable to toggle their value.

The code in this section uses the \texttt{life.js} source file.

To accomplish the stated vision, we create the \texttt{ConwaysGame} \emph{component} that will have as state a GOL grid, and a flag that determines wether the game is playing or is paused. We also need to handle the click of a cell, and the clicks of every button. The general structure of \texttt{ConwaysGame} is:

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:orgb16d8f0}
\begin{minted}[]{js}
class ConwaysGame extends React.Component {
  <<gol-constructor>>
  <<gol-timer-setup>>
  <<gol-simulation>>
  <<gol-grid-click>>
  <<gol-play-pause-click>>
  <<gol-clear-click>>
  <<gol-randomize-click>>
  render() { 
    return (
        <<gol-view>>
    );
  }
}
\end{minted}

\subsection{Evolving life periodically}
\label{sec:orgc6ab1a2}

The first thing we must set in place is the ability to update the grid as times goes on. This is done by setting a timer with the \texttt{setInterval} function, and with each tick of the timer we evolve the state of GOL. The \texttt{componentDidMount} function from the React component lifecycle, get's called after the rendering of the component, here we set an interval with ticks every 10 milliseconds. The \texttt{componentWillUnmount} function get's called before the component is removed from the DOM, here we clear the interval which will stop calling the \texttt{evolve} function.

\subsubsection*{\texttt{<<gol-timer-setup>>}}
\label{sec:org7b079c8}
\begin{minted}[]{js}
componentDidMount() {
  this.gameId = setInterval(() => this.evolve(), 10);
}

componentWillUnmount() {
  clearInterval(this.gameId);
}
\end{minted}

The definition of the \texttt{evolve} function is pretty straight-forward. When the simulation must be playing (that is, when \texttt{state.playing} is \texttt{true}) we must set a new state with \texttt{state.grid} updated to a new GOL configuration given by \texttt{life.evolve}:

\subsubsection*{\texttt{<<gol-simulation>>}}
\label{sec:org5d0f312}
\begin{minted}[]{js}
evolve() {
  if (this.state.playing) {
    this.setState((previous, props) => ({
      grid: life.evolve(previous.grid),
      playing: previous.playing
    }));
  }
}
\end{minted}

\subsection{Controlling the grid}
\label{sec:orgd30bd19}

There are four different ways to controll the grid:
\begin{itemize}
\item Clicking on a particular location of the grid.
\item Clicking the play/pause button.
\item Clicking the clear button.
\item Clicking the randomize button.
\end{itemize}

The \texttt{handleGridClick} function will take the clicked location as arguments and change the internal state to a toggled version of that location, that is, if the cell was dead now it will be alive and vice versa.

\subsubsection*{\texttt{<<gol-grid-click>>}}
\label{sec:org89028b4}
\begin{minted}[]{js}
handleGridClick(i, j) {
  const grid = this.state.grid;
  const cell = life.ref(grid, i, j);
  const modcell = (cell == life.alive) ? life.dead : life.alive;
  let modgrid = life.make(life.countRows(grid), life.countCols(grid),
                          (k, p) => ((i == k) && (j == p) ? modcell : life.ref(grid, k, p)));
  this.setState((previous, props) => ({
    grid: modgrid,
    playing: previous.playing
  }));
}
\end{minted}

The \texttt{handlePlayPause} function will be a thunk that toggles the value of \texttt{state.playing}:

\subsubsection*{\texttt{<<gol-play-pause-click>>}}
\label{sec:orgfba2739}
\begin{minted}[]{js}
handlePlayPauseClick() {
  this.setState({
    grid: this.state.grid,
    playing: !this.state.playing
  });
}
\end{minted}

The \texttt{handleClearClick} function will be a thunk that resets \texttt{state.grid} to just dead cells:

\subsubsection*{\texttt{<<gol-clear-click>>}}
\label{sec:orgad08d93}
\begin{minted}[]{js}
handleClearClick() {
  const grid = this.state.grid;
  let modgrid = life.make(life.countRows(grid), life.countCols(grid), () => life.dead);
  this.setState({
    grid: modgrid,
    playing: this.state.playing
  });
}
\end{minted}

Finally, the \texttt{handleRandomizeClick} will be a thunk that resets \texttt{state.grid} to cells either dead or alive with a random distribution:

\subsubsection*{\texttt{<<gol-randomize-click>>}}
\label{sec:org8ac9ccc}
\begin{minted}[]{js}
handleRandomizeClick() {
  const grid = this.state.grid;
  let randomgrid = life.make(life.countRows(grid), life.countCols(grid),
                             () => this.randomCell());
  this.setState({
    grid: randomgrid,
    playing: this.state.playing
  });
}

randomCell() {
  const outcomes = [life.dead, life.alive];
  return outcomes[Math.floor(outcomes.length * Math.random())];
}
\end{minted}

\subsection{GOL initialization}
\label{sec:org3a4ad5a}

The \texttt{ConwaysGame} component will be instantiated as:
\begin{minted}[]{html}
<ConwaysGame nrows=n ncols=m />
\end{minted}
so that we can access the \texttt{nrows} and \texttt{ncols} properties, which determine the size of the grid.

The constructor does the basic initialization: setting the initial state and binding the \texttt{this} value for the functions defined previously:

\subsubsection*{\texttt{<<gol-constructor>>}}
\label{sec:orgafc5aa2}
\begin{minted}[]{js}
constructor(props) {
  super(props);
  const nrows = props.nrows;
  const ncols = props.ncols;
  this.state = {
    grid: life.make(nrows, ncols, () => life.dead),
    playing: false
  };
  this.handleGridClick = this.handleGridClick.bind(this);
  this.handlePlayPauseClick = this.handlePlayPauseClick.bind(this);
  this.handleClearClick = this.handleClearClick.bind(this);
  this.handleRandomizeClick = this.handleRandomizeClick.bind(this);
  this.evolve = this.evolve.bind(this);
}
\end{minted}

Finally we setup the \texttt{render} function return value, which delegates the rendering of the controls and the grid to the \texttt{PlayPauseButton}, \texttt{ClearButton}, \texttt{RandomizeButton} and \texttt{VisualGrid} components, which will be simpler than \texttt{ConwaysGame} and won't hold any state.

\subsubsection*{\texttt{<<gol-view>>}}
\label{sec:org0d931f6}
\begin{minted}[]{html}
<div className="gol-main">
  <div className="gol-controls">
    <PlayPauseButton
      callback={this.handlePlayPauseClick}
      status={this.state.playing} />
    <ClearButton
      callback={this.handleClearClick} />
    <RandomizeButton
      callback={this.handleRandomizeClick} />
  </div>
  <VisualGrid
    callback={this.handleGridClick}
    grid={this.state.grid} />
</div>
\end{minted}

\subsection{Playing and pausing the game}
\label{sec:org938d16a}

The \texttt{PlayPauseButton} component renders different buttons depending on the value of \texttt{props.status}:

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:orgd06e054}
\begin{minted}[]{js}
function PlayPauseButton(props) {
  const status = props.status;
  if (status) {
    return (
        <<control-pause>>
    );
  } else {
    return ( 
        <<control-play>>
    );
  }
}
\end{minted}

These buttons are represented in the following way:

\subsubsection*{\texttt{<<control-pause>>}}
\label{sec:org38bf405}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-pause">
  <b>Pause</b>
</button>
\end{minted}

\subsubsection*{\texttt{<<control-play>>}}
\label{sec:orgbc39e4d}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-play">
  <b>Play</b>
</button>
\end{minted}

\subsection{Clearing and randomizing the game}
\label{sec:orgb06bee8}

These buttons are simmilar to \texttt{PlayPauseButton}:

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:orge15bfa7}
\begin{minted}[]{js}
function ClearButton(props) {
  return ( 
      <<control-clear>>
  );
}
\end{minted}

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:orga400627}
\begin{minted}[]{js}
function RandomizeButton(props) {
  return (
      <<control-randomize>> 
  );
}
\end{minted}

Where \texttt{<<control-clear>>} and \texttt{<<control-randomize>>} have obvious definitions:

\subsubsection*{\texttt{<<control-clear>>}}
\label{sec:org1374dae}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-clear">
  <b>Clear</b>
</button>
\end{minted}

\subsubsection*{\texttt{<<control-randomize>>}}
\label{sec:orgecbddcc}
\begin{minted}[]{html}
<button onClick={props.callback} className="btn-randomize">
  <b>Randomize</b>
</button>
\end{minted}

\subsection{Grid visualization}
\label{sec:org554eb03}

This last component takes care of rendering the grid as an HTML table, where each cell has a different click callback:

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:org08d783b}
\begin{minted}[]{js}
function VisualGrid(props) {
  const grid = props.grid;
  let rows = Array(life.countRows(grid));
  for (let i = 0; i < life.countRows(grid); i++) {
    let arr = Array(life.countCols(grid));
    for (let j = 0; j < life.countCols(grid); j++) {
      let cell = life.ref(grid, i, j);
      arr[j] = (
          <<table-cell>>
      );
    }
    rows[i] = (
        <<table-row>>
    );
  }
  return (
      <<table-main>>
  );
}
\end{minted}

The visual representation of a cell's value is the background color of an HTML table cell:

\subsubsection*{\texttt{<<table-cell>>}}
\label{sec:orgc454e14}
\begin{minted}[]{html}
<td key={j} className="cell" style={{backgroundColor: (cell == life.alive ? "white" : "black")}}
    onClick={ () => props.callback(i, j) }
  />
\end{minted}

The rest of the table structure is trivial:

\subsubsection*{\texttt{<<table-row>>}}
\label{sec:org47e04f4}
\begin{minted}[]{html}
<tr key={i}>
  { arr }
</tr>
\end{minted}

\subsubsection*{\texttt{<<table-main>>}}
\label{sec:orge2f7d9a}
\begin{minted}[]{html}
<table className="grid">
  <tbody>
    { rows }
  </tbody>
</table>
\end{minted}

\subsection{Rendering into the DOM}
\label{sec:org090ab60}

The last step is render the \texttt{ConwaysGame} component in the DOM, we do this with the \texttt{render} function from \texttt{ReactDOM}. The following chunk of code injects \texttt{<<conways-game>>} in the HTML element with ID \texttt{root}:

\subsubsection*{\texttt{<src/reactlife.jsx>}}
\label{sec:org8b34365}
\begin{minted}[]{js}
ReactDOM.render(
  <<conways-game>>,
  document.getElementById('root')
);
\end{minted}

The number of rows and columns are set to 30:

\subsubsection*{\texttt{<<conways-game>>}}
\label{sec:orgab6ad4b}
\begin{minted}[]{html}
<ConwaysGame ncols={45} nrows={45} />
\end{minted}

\section{The HTML document}
\label{sec:org9faca87}

This last section includes the main HTML and CSS files:

\subsubsection*{\texttt{<src/index.html>}}
\label{sec:org0d36982}
\begin{minted}[]{html}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Conway's Game of Life</title>
    <script src="https://unpkg.com/react@latest/dist/react.js"></script>
    <script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <link rel="stylesheet" type="text/css" 
          href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Alegreya" rel="stylesheet">
    <style> body { font-family: 'Alegreya', serif; } </style>
    <style> h1, h2, h3 { font-family: 'Alegreya', serif; } </style>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="text-align: center;">Conway's Game of Life Demo</h1>
    <div id="root"></div>

    <script src="grid.js"></script>
    <script src="life.js"></script>
    <script type="text/babel" src="reactlife.jsx"></script>
  </body>
</html>
\end{minted}

\subsubsection*{\texttt{<src/style.css>}}
\label{sec:org50f0a6a}
\begin{minted}[]{css}
.gol-main {}

.gol-controls {
    text-align: center;
}

.btn-pause {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-play {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-clear {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.btn-randomize {
    margin: 10px;
    width: 100px;
    display: inline-block;
    background-color: #eee8d5;
    border: 1pt solid #93a1a1;
    color: #d33682;
}

.cell {
    display: inline-block;
    width: 22px;
    height: 22px;
    cursor: pointer;
    margin: 0px;
    padding: 0px;
    border: solid 1px #333;
}

.grid {
    margin: auto;
    border-spacing: 0px;
    border: solid 2px #333;
}
\end{minted}
\end{document}